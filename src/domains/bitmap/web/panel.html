<!--
  BitMap Details Webview Panel (Foxtrot-VSCode)
  --------------------------------------------
  Provides four tree-navigators (Databases, Runs, Bit-streams, Notebooks),
  plus feature-mask management and clustering-algorithm inputs.

  Conventions applied:
    • File header & lang attribute (accessibility)
    • CSP nonce guard (security)
    • Strict-mode IIFE to avoid accidental globals
    • Debounced search filtering for performance
    • ARIA labels, accessible colours, outline reset
    • Tidied identifiers & numeric separators for readability
-->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <!-- CSP: default none; only inline styles and the single nonce-scoped script are allowed -->
  <meta http-equiv="Content-Security-Policy"
        content="default-src 'none'; img-src vscode-resource: data:; script-src 'nonce-__nonce__'; style-src 'unsafe-inline';"/>
  <style>
    :root {
      --accent  : #ff7e20;
      --active  : #2cdd6e;
      --bgPanel : color-mix(in srgb, var(--vscode-sideBar-background) 75%, var(--vscode-editor-background) 25%);
      --bgCard  : var(--vscode-sideBar-background);
      --crumb   : color-mix(in srgb, var(--vscode-editor-foreground) 65%, transparent);
    }

    body {
      font-family: var(--vscode-font-family);
      padding: 8px;
      background: var(--bgPanel);
    }

    /* ── cards / lists ─────────────────────────────────────────── */
    .section {
      background: var(--bgCard);
      padding: 6px;
      border-radius: 4px;
      box-shadow: 0 1px 1px rgb(0 0 0 / .25);
      margin-bottom: 10px;
    }

    h3 {
      margin: 0 0 6px;
      font-size: 12px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: .4px;
    }

    .search {
      width: 100%;
      box-sizing: border-box;
      padding: 3px 6px;
      margin-bottom: 6px;
      border-radius: 3px;
      border: 1px solid var(--vscode-sideBar-border);
      background: var(--vscode-input-background);
      color: var(--vscode-input-foreground);
    }

    .search:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 1px var(--accent);
      outline: none; /* remove default outline to avoid double ring */
    }

    .active-banner {
      display: flex;
      gap: 6px;
      align-items: center;
      padding: 2px 0 2px 3px;
      margin-bottom: 6px;
      border-left: 3px solid var(--active);
    }

    .active-label { white-space: nowrap; }
    .active-path  {
      font-size: 11px;
      color: var(--crumb);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .breadcrumb {
      font-size: 11px;
      color: var(--crumb);
      margin: 0 0 6px;
      display: flex;
      gap: 3px;
      flex-wrap: wrap;
    }

    .breadcrumb span       { cursor: pointer; }
    .breadcrumb span:hover { text-decoration: underline; }

    .item {
      padding: 3px 6px;
      cursor: pointer;
      border-radius: 3px;
    }

    .item:hover { background: var(--vscode-list-hoverBackground); }

    .item.leaf.active {
      border-left: 3px solid var(--active);
      padding-left: 3px;
    }

    /* ── feature-mask list & params ───────────────────────────── */
    .mask-row  { display: flex; align-items: center; gap: 6px; margin: 2px 0; }
    .mask-path { flex: 1 1 auto; overflow: hidden; text-overflow: ellipsis; }

    .param-row        { display: flex; align-items: center; gap: 8px; margin: 4px 0; }
    .param-row label  { width: 160px; font-size: 12px; white-space: nowrap; }
    .param-row input  { flex: 1 1 auto; padding: 3px 4px; font-size: 12px; }

    /* ── primary button ───────────────────────────────────────── */
    .primary-btn {
      padding: 6px 12px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      background: var(--vscode-button-background);
      color: var(--vscode-button-foreground);
    }

    .primary-btn:disabled {
      opacity: .6;
      cursor: default;
      background: var(--vscode-button-secondaryBackground);
    }
  </style>
</head>

<body>
  <!-- Pickers -->
  <div id="dbs"        class="section"></div>
  <div id="runs"       class="section"></div>
  <div id="bitstreams" class="section"></div>
  <div id="nbs"        class="section"></div>

  <!-- Feature masks -->
  <div id="masks" class="section"></div>

  <!-- Algorithm & sweep -->
  <div id="algo" class="section"></div>

  <!-- All logic wrapped inside a strict-mode IIFE to prevent accidental globals -->
  <script nonce="__nonce__">
    (function () {
      "use strict";

      /** @typedef {{label:string,path:string,children?:TreeNode[]}} TreeNode */

      const vscode = acquireVsCodeApi();

      /* ── panel-level state (persisted back to extension) ───────── */
      /** @type {{masks:{path:string}[],algo:string,params:Record<string,string>}} */
      let panelState = { masks: [], algo: "DBSCAN", params: {} };
      let latestDbPath = null;
      let latestBsPath = null;

      const algoParams = {
        HDBSCAN: ["min_cluster_size", "min_samples", "alpha", "cluster_selection_epsilon"],
        DBSCAN : ["eps", "min_samples"],
        KMeans : ["n_clusters"],
      };

      /* ─── helpers ─────────────────────────────────────────────── */
      const byId = (id) => /** @type {HTMLElement} */ (document.getElementById(id));

      function updateCreateBtn() {
        const btn = /** @type {HTMLButtonElement} */ (byId("createBtn"));
        if (btn) btn.disabled = !(latestDbPath && latestBsPath);
      }

      function sendUpdate() {
        vscode.postMessage({ type: "panel:update", value: panelState });
      }

      /* ─── Feature-Mask UI ─────────────────────────────────────── */
      function renderMasks() {
        const host = byId("masks");
        host.innerHTML = /*html*/`
          <h3>Feature Masks</h3>
          <div id="maskList"></div>
          <button id="addMaskBtn" class="primary-btn" aria-label="Add feature mask">+ Add mask</button>`;

        const list = byId("maskList");
        list.innerHTML = panelState.masks.map((m, i) => /*html*/`
          <div class="mask-row" data-idx="${i}">
            <span class="mask-path" title="${m.path}">${m.path}</span>
            <button class="removeMask" aria-label="Remove mask">✖</button>
          </div>`).join("");

        list.querySelectorAll(".removeMask").forEach((btn) => {
          btn.addEventListener("click", () => {
            const idx = parseInt(btn.parentElement.dataset.idx, 10);
            panelState.masks.splice(idx, 1);
            renderMasks();
            sendUpdate();
          });
        });

        byId("addMaskBtn").addEventListener("click", () =>
          vscode.postMessage({ type: "masks:browse" }));
      }

      /* ─── Algorithm & Sweep UI ────────────────────────────────── */
      function renderAlgo() {
        const host = byId("algo");
        host.innerHTML = /*html*/`
          <h3>Algorithm &amp; Sweep</h3>
          <select id="algoSel" aria-label="Select clustering algorithm">
            <option>HDBSCAN</option><option>DBSCAN</option><option>KMeans</option>
          </select>
          <div id="paramList"></div>
          <button id="createBtn" class="primary-btn" disabled
                  aria-label="Create analysis">Create analysis ▶︎</button>`;

        const sel = /** @type {HTMLSelectElement} */ (byId("algoSel"));
        sel.value = panelState.algo;
        sel.addEventListener("change", () => {
          if (panelState.algo === sel.value) return; // no-op if unchanged
          panelState.algo = sel.value;
          buildInputs();
          sendUpdate();
        });

        byId("createBtn").addEventListener("click", () =>
          vscode.postMessage({ type: "analysis:create" }));

        function buildInputs() {
          const list = byId("paramList");
          const names = algoParams[panelState.algo] ?? [];
          list.innerHTML = names.map((n) => /*html*/`
            <div class="param-row">
              <label>${n}</label>
              <input id="param-${n}" placeholder="value or sweep (start:step:end)"
                     value="${panelState.params[n] ?? ""}">
            </div>`).join("");

          names.forEach((n) => {
            /** @type {HTMLInputElement} */ (byId(`param-${n}`)).addEventListener("input", (e) => {
              panelState.params[n] = e.target.value;
              sendUpdate();
            });
          });
        }

        buildInputs();
        updateCreateBtn(); // ensure correct state after (re)render
      }

      /* ─── Tree Navigator factory ──────────────────────────────── */
      /**
       * @param {string} id
       * @param {string} title
       * @param {string} placeholder
       */
      function Navigator(id, title, placeholder) {
        const host = byId(id);
        host.innerHTML = /*html*/`
          <h3>${title}</h3>
          <input class="search" placeholder="${placeholder}" aria-label="${title} search"/>
          <div class="banner"></div>
          <div class="breadcrumb"></div>
          <div class="list"></div>`;

        const searchInput = /** @type {HTMLInputElement} */ (host.querySelector(".search"));
        const bannerEl    = host.querySelector(".banner");
        const breadcrumbEl = host.querySelector(".breadcrumb");
        const listEl      = host.querySelector(".list");

        /** @type {TreeNode[]} */
        let root = [];
        /** @type {Record<string, TreeNode>} */
        let nodeIndex = {};
        /** @type {string|null} */
        let activePath = null;
        /** @type {string[]} breadcrumb stack */
        let stack = [""]; // "" represents root

        function renderBanner() {
          if (!activePath) { bannerEl.innerHTML = ""; return; }
          const node  = nodeIndex[activePath];
          const label = node?.label || activePath.split("/").pop();
          const path  = activePath.slice(1, -label.length - 1);
          bannerEl.innerHTML = /*html*/`
            <div class="active-banner">
              <span class="active-label">${label}</span>
              <span class="active-path">${path}</span>
            </div>`;
        }

        /**
         * @param {TreeNode[]} nodes
         */
        const listHTML = (nodes) => nodes.map((n) => {
          const cls = `item${!n.children?.length ? " leaf" : ""}${n.path === activePath ? " active" : ""}`;
          return `<div class="${cls}" data-path="${n.path}">${n.label}</div>`;
        }).join("");

        function showLevel() {
          const dir = stack.at(-1);
          const rows = dir === "" ? root : nodeIndex[dir].children || [];
          listEl.innerHTML = listHTML(rows);

          breadcrumbEl.innerHTML = stack.length > 1
            ? ['<span data-idx="0">home</span>']
                .concat(stack.slice(1).map((seg, i) =>
                  `<span data-idx="${i + 1}"> ▸ ${seg.split("/").pop()}</span>`))
                .join("")
            : "";

          renderBanner();
        }

        /** @param {TreeNode[]} nodes */
        function flatten(nodes) {
          return nodes.reduce((acc, n) => {
            acc[n.path] = n;
            if (n.children) Object.assign(acc, flatten(n.children));
            return acc;
          }, /** @type {Record<string, TreeNode>} */ ({}));
        }

        /**
         * @param {TreeNode[]} nodes
         * @param {string} prefix
         */
        function annotate(nodes, prefix = "") {
          return nodes.map((n) => {
            const full = n.path ?? `${prefix}/${n.label}`;
            const key  = full.startsWith("/") ? full : `/${full}`;
            return {
              ...n,
              path: key,
              children: n.children ? annotate(n.children, key) : undefined,
            };
          });
        }

        /* debounced search filter */
        const debounce = (fn, delay) => {
          let t;
          return (...args) => { clearTimeout(t); t = setTimeout(() => fn(...args), delay); };
        };

        searchInput.addEventListener("input", debounce(() => {
          const q = searchInput.value.toLowerCase();
          if (!q) { showLevel(); return; }
          listEl.innerHTML = listHTML(
            Object.values(nodeIndex).filter(
              (n) => !n.children?.length && n.path.toLowerCase().includes(q)
            )
          );
        }, 150));

        listEl.addEventListener("click", (e) => {
          const el = /** @type {HTMLElement|null} */ (e.target.closest(".item"));
          if (!el) return;
          const node = nodeIndex[el.dataset.path];

          if (node.children?.length) {
            stack.push(node.path);
            showLevel();
            return;
          }

          listEl.querySelector(".active")?.classList.remove("active");
          el.classList.add("active");
          activePath = node.path;
          vscode.postMessage({ type: `${id}:select`, value: node.path.slice(1) });
          stack = [""]; // reset to root
          showLevel();
        });

        breadcrumbEl.addEventListener("click", (e) => {
          const span = /** @type {HTMLElement|null} */ (e.target.closest("span"));
          if (!span) return;
          stack = stack.slice(0, parseInt(span.dataset.idx, 10) + 1);
          showLevel();
        });

        return {
          /**
           * Inject fresh data from extension host
           * @param {TreeNode[]} tree
           * @param {string | undefined} active
           */
          setData(tree, active) {
            root = annotate(tree);
            nodeIndex = flatten(root);
            activePath = active ? (active.startsWith("/") ? active : `/${active}`) : null;
            showLevel();
          },
        };
      }

      /* ─── Create navigators ───────────────────────────────────── */
      const dbs        = Navigator("dbs",        "Databases", ".db filter…");
      const runs       = Navigator("runs",       "Runs",      "filter runs…");
      const bitstreams = Navigator("bitstreams", "Bitstreams","filter bitstreams…");
      const nbs        = Navigator("nbs",        "Notebooks", "filter notebooks…");

      /* ─── message pump from extension ➜ webview ───────────────── */
      window.addEventListener("message", (e) => {
        const d = e.data;
        if (d.type !== "data") return;

        /* picker trees */
        dbs.setData       (d.dbs,        d.activeDbPath);
        runs.setData      (d.runs,       d.activeRunPath);
        bitstreams.setData(d.bitstreams, d.activeBsPath);
        nbs.setData       (d.nbs,        d.activeNbPath);

        /* hydrate persisted form state (if any) */
        if (d.formState) {
          panelState = d.formState;
          renderMasks();
          renderAlgo();  // also updates button state
        }

        /* remember latest selections & update button */
        latestDbPath = d.activeDbPath;
        latestBsPath = d.activeBsPath;
        updateCreateBtn();
      });

      /* ─── initial render + handshake ─────────────────────────── */
      renderMasks();
      renderAlgo();
      vscode.postMessage({ type: "init" });
    })();
  </script>
</body>
</html>
